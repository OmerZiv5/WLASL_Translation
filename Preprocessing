import cv2
import os
import shutil
import re
import random
import numpy as np
import matplotlib.pyplot as plt

# ==== CONFIGURATION ====
root_input_folder = "Raw Data"
output_folder = "output_frames"
frames_to_extract = 5
video_extensions = (".mp4", ".avi", ".mov", ".mkv")
num_repeats = 20
frame_offset_range = 5  # ± this many frames
saturation_scale = 1.5

os.makedirs(output_folder, exist_ok=True)

# ==== HELPER FUNCTIONS ====
def boost_saturation_and_grayscale(frame, saturation_scale=1.5):
    """Increase saturation, then convert to grayscale."""
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV).astype('float32')
    h, s, v = cv2.split(hsv)
    s *= saturation_scale
    s = np.clip(s, 0, 255)
    hsv = cv2.merge([h, s, v])
    saturated = cv2.cvtColor(hsv.astype('uint8'), cv2.COLOR_HSV2BGR)
    gray = cv2.cvtColor(saturated, cv2.COLOR_BGR2GRAY)
    return gray

# ==== MAIN LOOP ====
def preprocess():
    category_sample_ids = {}  # counter per category

    for dirpath, _, filenames in os.walk(root_input_folder):
        for filename in filenames:
            if not filename.lower().endswith(video_extensions):
                continue

            video_path = os.path.join(dirpath, filename)

            # Category = first folder under root_input_folder
            rel_path = os.path.relpath(video_path, root_input_folder)
            category = rel_path.split(os.sep)[0]

            # Prepare category output folder
            category_output_dir = os.path.join(output_folder, category)
            os.makedirs(category_output_dir, exist_ok=True)

            # Initialize counter if new category
            if category not in category_sample_ids:
                category_sample_ids[category] = 1

            print(f"Processing video: {filename} (Category: {category})")

            cap = cv2.VideoCapture(video_path)
            if not cap.isOpened():
                print(f"❌ Cannot open {filename}")
                continue

            total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
            if total_frames <= frames_to_extract:
                print(f"⚠ Not enough frames in {filename}")
                cap.release()
                continue

            interval = total_frames // (frames_to_extract + 1)

            for repeat in range(num_repeats):
                # === Normal version sample folder ===
                sample_id = category_sample_ids[category]
                sample_folder = os.path.join(category_output_dir, f"{category}_{sample_id:06d}")
                os.makedirs(sample_folder, exist_ok=True)
                category_sample_ids[category] += 1

                for i in range(1, frames_to_extract + 1):
                    offset = random.randint(-frame_offset_range, frame_offset_range)
                    frame_index = i * interval + offset
                    frame_index = max(0, min(frame_index, total_frames - 1))

                    cap.set(cv2.CAP_PROP_POS_FRAMES, frame_index)
                    ret, frame = cap.read()
                    if not ret:
                        print(f"⚠ Could not read frame {frame_index} in {filename}")
                        continue

                    processed_frame = boost_saturation_and_grayscale(frame)
                    frame_name = f"frame_{i}.jpg"
                    cv2.imwrite(os.path.join(sample_folder, frame_name), processed_frame)

                # === Mirrored version sample folder ===
                sample_id = category_sample_ids[category]
                mirrored_sample_folder = os.path.join(category_output_dir, f"{category}_{sample_id:06d}")
                os.makedirs(mirrored_sample_folder, exist_ok=True)
                category_sample_ids[category] += 1

                for i in range(1, frames_to_extract + 1):
                    offset = random.randint(-frame_offset_range, frame_offset_range)
                    frame_index = i * interval + offset
                    frame_index = max(0, min(frame_index, total_frames - 1))

                    cap.set(cv2.CAP_PROP_POS_FRAMES, frame_index)
                    ret, frame = cap.read()
                    if not ret:
                        print(f"⚠ Could not read frame {frame_index} in {filename}")
                        continue

                    processed_frame = boost_saturation_and_grayscale(frame)
                    mirrored_frame = cv2.flip(processed_frame, 1)
                    frame_name = f"frame_{i}.jpg"
                    cv2.imwrite(os.path.join(mirrored_sample_folder, frame_name), mirrored_frame)

            cap.release()

    print("✅ Done generating samples!")

def plot_filecount_histograms(root_dir, output_dir=None):
    """
    For each category (first-level subfolder), count files in each subfolder
    and plot a histogram of those counts.

    X-axis = number of files in subfolder
    Y-axis = number of subfolders with that file count
    """

    for category in os.listdir(root_dir):
        category_path = os.path.join(root_dir, category)
        if not os.path.isdir(category_path):
            continue

        # Gather file counts
        file_counts = []
        for subfolder in os.listdir(category_path):
            subfolder_path = os.path.join(category_path, subfolder)
            if not os.path.isdir(subfolder_path):
                continue

            count = sum(
                1 for f in os.listdir(subfolder_path)
                if os.path.isfile(os.path.join(subfolder_path, f))
            )
            file_counts.append(count)

        if not file_counts:
            continue

        # Plot histogram
        plt.figure(figsize=(8, 5))
        plt.hist(file_counts, bins=range(min(file_counts), max(file_counts) + 2),
                 edgecolor='black', color='skyblue', align='left')
        plt.title(f"Distribution of subfolder file counts in '{category}'")
        plt.xlabel("Number of files in subfolder")
        plt.ylabel("Number of subfolders")
        plt.xticks(range(min(file_counts), max(file_counts) + 1))
        plt.tight_layout()

        if output_dir:
            os.makedirs(output_dir, exist_ok=True)
            save_path = os.path.join(output_dir, f"{category}_histogram.png")
            plt.savefig(save_path)
            plt.close()
        else:
            plt.show()

def clean_and_rename_categories(root_dir, min_files=5):
    """
    Deletes subfolders with fewer than min_files files,
    then renumbers remaining ones so IDs are contiguous.

    Assumes subfolder names are like 'category_00010'.
    """

    for category in os.listdir(root_dir):
        category_path = os.path.join(root_dir, category)
        if not os.path.isdir(category_path):
            continue

        # Regex to match "category_id" with leading zeros allowed
        pattern = re.compile(rf"^{re.escape(category)}_(\d+)$")

        # Collect subfolders and their IDs
        subfolders = []
        for sub in os.listdir(category_path):
            match = pattern.match(sub)
            if match:
                sub_id = int(match.group(1))
                sub_path = os.path.join(category_path, sub)

                file_count = sum(
                    1 for f in os.listdir(sub_path)
                    if os.path.isfile(os.path.join(sub_path, f))
                )
                subfolders.append((sub_id, sub_path, file_count))

        # Sort by ID
        subfolders.sort(key=lambda x: x[0])

        # Step 1: Delete folders with too few files
        deleted_ids = set()
        for sub_id, sub_path, file_count in subfolders:
            if file_count < min_files:
                shutil.rmtree(sub_path)
                deleted_ids.add(sub_id)

        # Step 2: Renumber remaining ones
        shift_map = {}
        deleted_count_before = 0
        for sub_id, sub_path, file_count in subfolders:
            if sub_id in deleted_ids:
                deleted_count_before += 1
            else:
                new_id = sub_id - deleted_count_before
                shift_map[sub_id] = new_id

        # To avoid collisions, rename to a temp name first
        for sub_id, sub_path, file_count in sorted(
            ((i, p, c) for i, p, c in subfolders if i not in deleted_ids),
            key=lambda x: -x[0]  # rename highest IDs first
        ):
            new_id = shift_map[sub_id]
            new_name = f"{category}_{new_id:05d}"  # keep 5-digit padding
            temp_name = f"__TEMP__{new_id:05d}"
            temp_path = os.path.join(category_path, temp_name)
            os.rename(sub_path, temp_path)
            os.rename(temp_path, os.path.join(category_path, new_name))

plot_filecount_histograms("output_frames", output_dir="histograms")
#clean_and_rename_categories("output_frames", min_files=5)
